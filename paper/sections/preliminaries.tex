\section{Preliminaries}

\subsection{Conflict Graphs and Mazurkiewicz Traces}
Consider a set $\Cmd$ of commands and a binary reflexive relation $\conflict$
over $\Cmd$. We say two commands $x, y \in \Cmd$ \defword{conflict} if $(x, y)
\in \conflict$, and we say they are \defword{independent} otherwise. A
\defword{conflict graph}~\cite{mazurkiewicz1995introduction} (with respect to
$\Cmd$ and $\conflict$) is a directed acyclic graph $C = (V, E, \varphi)$ where
%
  $V$ is a set of vertices;
%
  $E \subseteq V \times V$ is a set of edges;
%
  $\varphi: V \to \Cmd$ is a function that labels every vertex with a command;
  and
%
  for every pair of vertices $v_1, v_2 \in V$, there exists an edge between
  $v_1$ and $v_2$ if and only if $\varphi(v_1)$ and $\varphi(v_2)$ conflict.
%
We say $C' = (V', E', \varphi|_{V'})$ is a \defword{suffix} of $C$ if $C'$ is a
subgraph of $C$ such that for every edge $(v_1, v_2) \in E$, if $v_1 \in V'$,
then $(v_1, v_2) \in E'$.
%
An example conflict graph is shown in \figref{ExampleConflictGraph} with $\Cmd
= \set{x, y, z}$ and $\conflict = \set{(x, x), (x, y), (y, x), (x, z), (z,
x)}$. A suffix of this conflict graph is shown in \figref{ExampleSuffix}.

{\input{figures/conflict_graph_example.tex}}

We associate every conflict graph with the set of command strings that can be
obtained by a reverse topological sort of the conflict graph. For example, the
conflict graph in \figref{ExampleConflictGraph} can be reverse topological
sorted in two ways, yielding the two command strings $xyzxy$ and $xzyxy$.
Moreover, notice that these two command strings can be obtained from one
another by interchanging their second and third commands, two commands that do
not conflict. This is true in general. Any two command strings associated with
a conflict graph can be obtained from the other by repeatedly interchanging
adjacent independent commands. These sets of command strings are known as
Mazurkiewicz traces~\cite{mazurkiewicz1985semantics,
mazurkiewicz1995introduction} and formalize the orders in which replicated
state machines can execute commands while remaining in sync.

\subsection{Generalized Consensus}
Generalized consensus~\cite{lamport1998part, sutra2011fast} involves a set of
processes known as \defword{learners} attempting to reach consensus on a
growing value. Though generalized consensus is defined in terms of an abstract
data structure known as a command-structure set, we restrict our attention to
generalized consensus on conflict graphs. More formally, given a set $\Cmd$ of
commands and conflict relation $\conflict$, we consider a set $l_1, l_2,
\ldots, l_n$ of learners where each learner $l_i$ manages a conflict graph
$C_i$. Over time, a set of client processes propose commands, and learners add
the proposed commands to their conflict graphs such that the following four
conditions are maintained.
\begin{itemize}
  \item \defword{Nontriviality:}
    The vertices of every conflict graph are labelled only with proposed
    commands.
  \item \defword{Stability:}
    Every conflict graph $C_i$ at time $t$ is a suffix of $C_i$ at any time after
    $t$.
  \item \defword{Consistency:}
    For every pair of conflict graphs $C_i$ and $C_j$, there exists a conflict
    graph $C$ such that $C_i$ and $C_j$ are both suffixes of $C$.
  \item \defword{Liveness:}
    If a command is proposed, then eventually every conflict graph contains it.
\end{itemize}

\subsection{BPaxos Graphs and Partial BPaxos Graphs}
Consider again a set $\Cmd$ of commands and a binary reflexive relation
$\conflict$ over $\Cmd$. A \defword{BPaxos graph} (with respect to $\Cmd$ and
$\conflict$) is a directed (potentially cyclic) graph $B = (V, E, \varphi)$
where
%
  $V$ is a set of vertices;
%
  $E \subseteq V \times V$ is a set of edges;
%
  $\varphi: V \to \Cmd$ is a partial function that labels a subset of the
  vertices with a command;
%
  for every pair of vertices $v_1, v_2 \in V$, there exists an edge between
  $v_1$ and $v_2$ if (but not only if) $\varphi(v_1)$ and $\varphi(v_2)$
  conflict.
%
Intuitively, a BPaxos graph is a potentially cyclic conflict graph that can
have spurious edges between vertices labelled with non-conflicting commands.

A \defword{partial BPaxos graph} $B = (V, E, \varphi)$ is a BPaxos graph except
that $\varphi: V \partialto \Cmd$ is partial. Intuitively, a partial BPaxos
graph is a BPaxos graph for which the labels of some vertices are unknown.
%
We say a vertex $v$ in a partial BPaxos graph is \defword{eligible} if $v$
and all of the ancestors of $v$ are labelled. The \defword{eligible suffix} of
a partial BPaxos graph $B$ is the suffix of $B$ consisting of all eligible
vertices.
%
An example partial BPaxos graph is illustrated in \figref{PartialBPaxosGraph},
and its eligible suffix is shown in \figref{EligibleSuffix}.

{\input{figures/condensation_example.tex}}

The \defword{condensation} of BPaxos graph $B$ is the graph obtained by first
removing spurious edges between non-conflicting vertices in $B$ and then by
contracting every strongly connected component. Every strongly connected
component labelled with commands $x_1, \ldots, x_n$ is replaced with a single
vertex labelled with a command string $x_{i_1} x_{i_2} \cdots x_{i_n}$ that is
obtained from an arbitrary but fixed ordering of the commands $x_1, \ldots,
x_n$. An example condensation is shown in \figref{Condensation}.
%
The condensation of a BPaxos graph with respect to $\Cmd$ and $\conflict$ is
a conflict graph with respect to $\Cmd^+$ and $\conflict^+$ where $\Cmd^+$ is
the set of non-empty command strings and where $(x_1 x_2 \cdots x_n, y_1 y_2
\cdots y_m) \in \conflict^+$ if there is some $x_i$ and $y_j$ that conflict in
$\conflict$.
