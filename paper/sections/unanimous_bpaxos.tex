\section{Unanimous BPaxos}\seclabel{UnanimousBPaxos}
\defword{Unanimous BPaxos} is identical to Unsafe BPaxos except for the
following small modifications.  First, we increase the fast quorum size from
$\SuperQuorumSize$ to $2f + 1$. Thus, choosing a value in round $0$ requires a
unanimous vote. Second, we implement Unanimous BPaxos with the Fast Paxos
tweak shown in \algoref{FastPaxosTweak} where value $v$ in
\lineref{FastPaxosTweakCase3} may have been chosen in round $0$ only if every
acceptor in $\Quorum$ voted for $v$ in round $0$.
%
Like Unsafe BPaxos, Unanimous BPaxos can choose a command in one round trip (in
the best case), but unlike Unsafe BPaxos, Unanimous BPaxos is safe.

Reiterating again \secref{BipartisanPaxos}, to prove the safety of Unanimous
BPaxos, it suffices to show that Unanimous BPaxos maintains
\invref{ConsensusInvariant} and \invref{ConflictInvariant}. Unanimous BPaxos
maintains \invref{ConsensusInvariant} trivially by using Fast Paxos. Like
Simple BPaxos, Unanimous BPaxos maintains \invref{ConflictInvariant} by
maintaining \invref{SimpleBpaxosInvariant}.

\begin{proof}
  To prove that Unanimous BPaxos maintains \invref{SimpleBpaxosInvariant}, we
  prove for every instance $I$ the claim $P(i)$ that says if a Fast Paxos
  acceptor votes for value $(x, \deps{I})$ in round $i$, then either $i = 0$,
  or $(I, x, \deps{I})$ is a response from the dependency service, or $(x,
  \deps{I}) = (\noop, \emptyset)$.
  %
  \invref{SimpleBpaxosInvariant} follows immediately from $P(i)$. We prove
  $P(i)$ by induction. $P(0)$ is trivial; the first disjunct of $P(0)$ is
  satisfied. For the general case, we perform a case analysis on Unanimous
  BPaxos node $b_i$ executing \algoref{FastPaxosTweak}.
  %
  If $b_i$ executes \lineref{FastPaxosTweakCase1Code} or
  \lineref{FastPaxosTweakCase4Code}, $b_i$ either proposes $\noop$ or proposes
  a response from the ordering service, so $P(i)$ holds trivially.
  %
  If $b_i$ executes \lineref{FastPaxosTweakCase2Code}, then $P(i)$ holds from
  $P(k)$.
  %
  If $b_i$ executes \lineref{FastPaxosTweakCase3Code}, then every acceptor in
  $\Quorum$ voted for $v$ in round $0$. Thus, if $v = (x, \deps{I})$, then
  every dependency service node colocated with an acceptor in $\Quorum$ replied
  with $(I, x, \deps{I})$, so the second clause of $P(i)$ holds.
\end{proof}

This concludes the proof of Unanimous BPaxos's safety, but let's not miss the
forest through the proof. Taking a step back, we see that increasing the fast
quorum size from $\SuperQuorumSize$ to $2f + 1$ fixes Unsafe BPaxos' lack of
safety by resolving the tension between maintaining \invref{ConsensusInvariant}
and \invref{ConflictInvariant}.  With Unsafe BPaxos, there were scenarios in
which a BPaxos node $b_i$ was simultaneously forced to propose a value $(v,
\deps{I})$ to maintain \invref{ConsensusInvariant} and forced \emph{not} to
propose $v$ to maintain \invref{ConflictInvariant}.  By increasing the fast
quorum size, we eliminate these scenarios, ensuring that if a BPaxos node $b_i$
is ever forced to propose a value $v = (x, \deps{I})$, it is guaranteed that
$\deps{I}$ was computed by the dependency service.
