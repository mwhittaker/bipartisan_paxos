\section{The Bipartisan Paxos Protocols}\seclabel{BipartisanPaxos}
The BPaxos protocols implement state machine replication. Informally, a set of
client processes repeatedly propose state machine commands, and a set of state
machine replicas all execute the commands in exactly the same order (modulo the
reordering of non-conflicting commands). In this section, we formalize state
machine replication by way of generalized consensus. We then overview the
common structure that underlies all of the BPaxos protocols.

\subsection{Problem Description}
The BPaxos protocols implement state machine replication by way of generalized
consensus. We assume an asynchronous network model and assume that processes
can fail by crashing (but cannot act maliciously). Throughout the paper, we
assume at most $f$ processes can fail.  We consider a set $b_1, b_2, \ldots,
b_{f+1}$ of deterministic state machine replicas that all begin in the same
initial state. We consider a set $\Cmd$ of state machine commands and define a
conflict relation $\conflict$ such that two commands $x, y \in \Cmd$ conflict
if they do not commute--i.e.\ if there exists a state in which executing $x$
and then $y$ does not produce the same responses and final state as executing
$y$ and then $x$.
%
Every BPaxos protocol is a generalized consensus protocol, with state machine
replicas playing the role of learners. Each replica $b_i$ learns a conflict
graph $C_i$ with respect to $\Cmd^+$ and $\conflict^+$. Every replica $b_i$
executes the commands in $C_i$ in reverse topological order as they are
learned. For example, if a replica has learned the conflict graph shown in
\figref{Condensation}, it can execute commands in the order $uwvxy$ or $uwvyx$.
Executing commands in this way, replicas are guaranteed to stay in sync,
producing identical responses for every command they execute.

\subsection{BPaxos Protocols Overview}
Every BPaxos protocol implements generalized consensus by first reaching
consensus on a partial BPaxos graph.
%
When a client process sends a state machine command $x$ to a BPaxos protocol, a
process implementing the protocol eventually assigns the command an identifier
$I$ called an \defword{instance} and a set of instances, $\deps{I}$, called the
\defword{dependencies} of $I$.
%
The BPaxos protocol implements one instance of consensus for every instance $I$
and eventually reaches consensus on the value $(x, \deps{I})$ in instance $I$.
Every state machine replica $b_i$ maintains a partial BPaxos graph $B_i$ where
instances play the role of vertices. When replica $b_i$ learns that an instance
$I$ has been chosen with command $x$ and dependencies $\deps{I}$, it adds
vertex $I$ to $B_i$ labelled with $x$ and with outbound edges to every instance
in $\deps{I}$ (adding previously unseen instances to $B_i$ as necessary).
Letting $C_i$ be the condensation of the eligible suffix of $B_i$, the BPaxos
protocol successfully implements generalized consensus with replica $b_i$
learning conflict graph $C_i$ so long as the following two invariants are met.

\begin{invariant}\invlabel{ConsensusInvariant}
  The BPaxos protocol successfully implements consensus for every instance $I$.
  That is, at most one value $(x, \deps{I})$ is chosen in instance $I$ (i.e.\
  consistency) and if the value $(x, \deps{I})$ is chosen, then it was
  previously proposed (i.e.\ nontriviality).
\end{invariant}
\begin{invariant}\invlabel{ConflictInvariant}
  If $(x, \deps{I_x})$ is chosen in instance $I_x$ and $(y, \deps{I_y})$ is
  chosen in instance $I_y$, and if $x$ and $y$ conflict, then either $I_x \in
  \deps{I_y}$ or $I_y \in \deps{I_x}$ or both.
\end{invariant}

\invref{ConsensusInvariant} allows replicas to reach consensus on their partial
BPaxos graphs. \invref{ConflictInvariant} ensures that every replica's partial
BPaxos graph really is a partial BPaxos graph.
%
These two invariants suffice to ensure stability and consistency. Stability is
guaranteed because a replica $b_i$'s partial BPaxos graph $B_i$ (and hence its
condensation $C_i$) only grows over time. Consistency is guaranteed because
every condensation $C_i$ is a prefix of the condensation of the eligible suffix
of the global partial BPaxos graph, the graph formed from complete knowledge of
every chosen instance.
%
Assuming the possibility of only a single process failure, guaranteeing
liveness is impossible~\cite{fischer1982impossibility}. The BPaxos protocols do
provide liveness with certain assumptions about the niceness of the network,
but we do not focus on liveness in this paper. Finally, every BPaxos protocol
ensures nontriviality in a straightforward way.

Every BPaxos protocol follows this pattern of reaching consensus on a partial
BPaxos graph one instance at a time and locally computing condensations of
eligible suffixes. The protocols differ only in how they compute dependencies
and how they reach consensus for a given instance. Thus, to prove the
correctness of a BPaxos protocol, it suffices to prove that the protocol
maintains \invref{ConsensusInvariant} and \invref{ConflictInvariant}.
