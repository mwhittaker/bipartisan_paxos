\section{Deadlock Bipartisan Paxos}
In this section, we present \defword{Deadlock Bipartisan Paxos}. Deadlock
BPaxos can commit commands in one round trip like Unanimous BPaxos, but
Deadlock BPaxos only requires a superquorum size of $f + \floor{\frac{f}{2}} +
1$. Unfortunately, there are situations in which Deadlock Paxos can deadlock.
We will fix this pesky liveness problem in the next section.

\paragraph{Ordering Service}
Deadlock BPaxos uses the same ordering service as BPaxos and Unanimous BPaxos.

\paragraph{Consensus Service}
Deadlock BPaxos uses the same consensus service as Unanimous BPaxos, except
that Deadlock BPaxos uses a superquorums size of $f + \floor{\frac{f}{2}} + 1$,
the same as regular Fast Paxos.

\paragraph{Overview}
In the normal case, Deadlock BPaxos nodes behave exactly like Unanimous BPaxos
nodes. Upon receiving a command $a$ from a client, a Deadlock BPaxos node $R$
chooses some previously unused instance $R.i$ for the command. It then sends
$(R.i, a)$ to the ordering service nodes.
%
When an ordering service node $o_j$ receives $(R.i, a)$, it proposes it's reply
$(R.i, a, \deps{a}_j)$ to $p_j$, the colocated Paxos acceptor. $p_j$ then sends
its vote back to $R$.
%
If $R$ receives a superquorum of matching votes $(R.i, a, \deps{a})$, then the
gadget is considered chosen. If it does not receive a superquorum of matching
votes, it enters recovery.

Recovery is where Deadlock BPaxos differs from the incorrect BPaxos variant in
\secref{IncorrectBPaxos} and from Unanimous BPaxos. Deadlock BPaxos proposers
implement Case 2 and Case 3 of \algoref{FastPaxosTweak} as described in
\algoref{DeadlockBPaxos}. The bulk of the complexity comes from resolving the
tension between maintaining \invref{GadgetsChosen} and
\invref{ConflictingGadgets}, as exemplified by the upper right corner of
\figref{BPaxosLogic}.

\paragraph{Pruned Dependencies}
We'll walk through \algoref{DeadlockBPaxos} momentarily, but first we pause to
understand one of the key invariants that it maintains. Recall that in order to
preserve \invref{ConflictingGadgets}, both BPaxos and Unanimous BPaxos maintain
the invariant that a proposer can only propose a value $(a, \deps{a})$ if
either $\deps{a}$ is a response from the ordering service or if $(a, \deps{a})
= (\noop, \emptyset)$.

Deadlock BPaxos does not maintain this invariant, Instead, it maintains an
invariant that is slightly weaker but still strong enough to imply
\invref{ConflictingGadgets}. The motivation for the weaker invariant is as
follows. Imagine a Deadlock BPaxos node $R$ sends command $a$ to the ordering
service in instance $I_a$, and the ordering service responds with $(I_a, a,
\deps{a})$. Let $I_b \in \deps{a}$ be one of $a$'s dependencies. Assume that
that $R$ knows that $I_b$ has been committed with command $b$ and dependencies
$\deps{b}$. Further assume that $I_a \in \deps{b}$. That is, there is an edge
from $I_b$ to $I_a$. In this case, there is no need for $R$ to include $I_b$ in
the dependencies of $I_a$! \invref{ConflictingGadgets} asserts that if two
committed commands conflict, one has an edge to the other (or both). If $I_b$
has already committed with an edge to $I_a$, there is no need to propose an
edge from $I_a$ back to $I_b$.
%
Similarly, if $I_b$ has been committed with a $\noop$, then there is no need to
propose an edge from $I_a$ to $I_b$ at all because $a$ and $\noop$ do not
conflict.

\newcommand{\pruned}{\text{pruned}}
Let $(I_a, a, \deps{a})$ be a response from the ordering service. Let $P$ be
the set of instances $I_c$ in $\deps{a}$ such that $I_c$ has been committed
with $I_a$ in its dependencies or $c$ is a $\noop$. Then, we call
$\pruned(\deps{a}) = \deps{a} - P$ the \defword{pruned dependencies} of $I_a$
(or $a$). Deadlock BPaxos maintains the following invariant:

\begin{boxedinvariant}\invlabel{PrunedDependencies}
  A Deadlock BPaxos node will only propose a value $(a, \deps{a})$ in instance
  $I_a$ if $\deps{a}$ is a pruned response from the ordering service or if $a =
  \noop$ and $\deps{a} = \emptyset$.
\end{boxedinvariant}

\invref{GadgetsChosen} and \invref{PrunedDependencies} imply
\invref{ConflictingGadgets}. To see why, consider two conflicting commands $a$
and $b$ chosen in instances $I_a$ and $I_b$ with pruned dependencies
$\pruned(\deps{a})$ and $\pruned(\deps{b})$ derived from unpruned dependencies
$\deps{a}$ and $\deps{b}$ from the ordering service. We want to show that $I_a
\in \pruned(\deps{a})$ or $I_b \in \pruned(\deps{a})$, or both. Note that $a$
and $b$ conflict, so we know that neither is a $\noop$ and that their unpruned
dependencies are from the ordering service.
%
By \invref{OrderingService}, either $I_b \in \deps{a}$ or $I_a \in \deps{b}$ or
both. Without loss of generality, assume $I_b \in \deps{a}$. If $I_b$ is also
in $\pruned(\deps{a})$, then we're done. Otherwise, $I_b$ has been pruned from
$\deps{a}$. This happens only if $b$ is a $\noop$ or if $I_b$ has been chosen
with $I_a \in \deps{b}$. $b$ is not a $\noop$, so $I_a \in \deps{b}$, and we're
done.

\paragraph{Deadlock BPaxos Nodes}
\begin{algorithm}[ht]
  \caption{Deadlock BPaxos recovery for instance $R.i$ (Case 2 and Case 3)}%
  \algolabel{DeadlockBPaxos}
  \begin{algorithmic}[1]
    \If{%
      $\nexists v \in V$ such that at least $\QuorumMajoritySize$ acceptors in
      $\quorum$ voted for $v$
    }
      \State{} propose anything
    \EndIf{}

    \State{}
    \State{} $(a, \deps{a}) \gets$ the value voted by at least
             $\QuorumMajoritySize$ acceptors in $\quorum$
    \State{} Send $(R.i, a)$ to the quorum $\quorum$ of ordering service nodes
    \State{} $\deps{a}' \gets$ the union of ordering service responses

    \State{}
    \If{$\deps{a} = \deps{a}'$}
      \State{} propose $(a, \deps{a})$
    \EndIf{}
    \For{$I_b \in \deps{a}' - \deps{a}$}
      \If{$I_b$ not committed}
        \State{} recover $I_b$
      \EndIf
      \If{$I_b$ committed with $\noop$}
        \State{} continue
      \EndIf{}
      \If{$I_b$ committed with $R.i \in \deps{b}$}
        \Comment{$b \to a$ unpruned}
        \State{} continue
      \ElsIf{$I_b$ committed with $R.i$ not in the unpruned $\deps{b}$}
        \Comment{$b \not\to a$}
        \State{} propose anything
      \Else{}
        \Comment{$b \not\to a$ pruned}
        \State{} $I_b$ committed with $R.i$ in unpruned $\deps{b}$
        \State{} abort recovery; $R.i$ has already been chosen
      \EndIf{}
    \EndFor{}
    \State{} propose $(a, \deps{a})$
  \end{algorithmic}
\end{algorithm}

Now, we walk through \algoref{DeadlockBPaxos} for a Deadlock BPaxos node $S$
recovering instance $R.i$. If there does not exist a value $v \in V$ with at
least $\QuorumMajoritySize$ votes from acceptors in $\quorum$, then no value
could have been chosen in round $0$, so $S$ is free to propose anything.

Otherwise, there is some $(a, \deps{a})$ that was voted by a majority of
$\quorum$. As we saw with the incorrect BPaxos variant in
\secref{IncorrectBPaxos}, we cannot blindly propose $(a, \deps{a})$ because
it's possible that $\deps{a}$ is not a response from the ordering service.
Thus, $S$ has to do a bit of detective work to determine either that $\deps{a}$
is indeed a response from the ordering service or that $(a, \deps{a})$ was
definitely not chosen.

First, $S$ sends $(R.i, a)$ to every ordering service node in $\quorum$ and
gathers the union of their responses, $\deps{a}'$. Note that these requests can
be piggybacked on the phase 1a messages previously sent by $S$ to eliminate the
extra round trip. A majority of the acceptors in $\quorum$ voted for
$\deps{a}$, and $\deps{a}'$ is a union of these responses (and the responses
from the other acceptors in $\quorum$), so $\deps{a}'$ is either equal to
$\deps{a}$ or a superset of $\deps{a}$.

If $\deps{a} = \deps{a}'$, then $\deps{a}$ is a response from the ordering
service, so $S$ is free to propose it. Otherwise, $\deps{a}'$ is a superset of
$\deps{a}$. $S$ then enters a for loop in an attempt to prune $\deps{a}'$ until
it's either equal to $\deps{a}$ or until it determines that $\deps{a}$ could
not have been chosen in the first place.

For every, $I_b \in \deps{a}' - \deps{a}$, $S$ first gets $I_b$ committed if it
isn't already. To commit $I_b$, $S$ simply begins the recovery process for
$I_b$. If $I_b$ is a $\noop$ or if $R.i \in \deps{b}$, then we can prune $I_b$
and move on to the next $I_b$. Otherwise, $I_b$ is not a $\noop$ and is
committed without $R.i \in \deps{b}$. Now, $\deps{b}$ is a (possibly) pruned
response from the ordering service. Let the corresponding unpruned dependencies
be $\deps{b}'$. We perform a case analysis on whether $R.i \in \deps{b}'$.
\begin{itemize}
  \item \textbf{Case $R.i \notin \deps{b}'$.}
    If $R.i \notin \deps{b}'$, then there is some quorum of ordering service
    nodes that processed $I_b$ before $R.i$. Then, it is impossible for there
    to be a superquorum of nodes that processed $R.i$ before $I_b$. Thus,
    $\deps{b}$ cannot have been chosen on the fast path in round $0$. In this
    case, we are free to propose anything.

  \item \textbf{Case $R.i \in \deps{b}'$.}
    If $R.i \in \deps{b}'$, then it has been pruned from $\deps{b}'$. Thus,
    either $R.i$ has been committed as a $\noop$ or $R.i$ has been committed
    with $I_b \in \deps{a}$. In either case, $R.i$ has been committed, so we
    abort recovery for $R.i$.
\end{itemize}
\TODO[mwhittaker]{%
  Add explicitly the tracking of pruned dependencies, so we can distinguish
  between these two cases.
}

Finally, if $S$ exits the for loop, then it has pruned $\deps{a}'$ into
$\deps{a}$ and can now propose it.

\paragraph{Correctness}
Deadlock BPaxos satisfies \invref{GadgetsChosen} by using Fast Paxos. It
satisfies \invref{ConflictingGadgets} by satisfying
\invref{PrunedDependencies}. It satisfies \invref{PrunedDependencies} because
every proposal issued in \algoref{DeadlockBPaxos} is a proposal for $\noop$ or
a pruned response from the ordering service.

\paragraph{Deadlock}
\TODO[mwhittaker]{Mention deadlock with explicit example.}

\tikzstyle{smallsquare}=[%
  draw,
  line width=1pt,
  minimum height=0.4in,
  minimum width=0.3in,
  text width=0.3in,
  align=center
]
\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[xscale=2.5, yscale=2]
    \node[smallsquare] (a) at (1, 1) {$a$};
    \node[smallsquare] (dep1) at (0.5, 0) {$b_1$};
    \node[smallsquare] (dep2) at (1, 0) {$b_2$};
    \node[smallsquare] (dep3) at (1.5, 0) {$b_3$};
    \node[smallsquare] (c) at (2, 1) {$c$};

    \node[above=0in of a] {$I_a$};
    \node[below=0in of dep1] {$I_{b_1}$};
    \node[below=0in of dep2] {$I_{b_2}$};
    \node[below=0in of dep3] {$I_{b_3}$};
    \node[above=0in of c] {$I_c$};

    \draw[ultra thick, -latex] (a) to (dep1);
    \draw[ultra thick, -latex] (a) to (dep2);
    \draw[ultra thick, -latex] (a) to (dep3);
    \draw[ultra thick, -latex] (a) to (c);

    \node[%
      draw=red,
      line width=1pt,
      rounded rectangle,
      minimum width=2in,
      minimum height=1in,
      label={270:$\deps{a}$}
    ] () at (dep2) {};
  \end{tikzpicture}
  \caption{Deadlock BPaxos recovery comic}\figlabel{FastBPaxosNotUnion}
\end{figure}

First, $Q$ sends $(I_a, a)$ to a quorum $\mathcal{Q}$ of $f + 1$ ordering
service nodes%
\footnote{%
  Note that $Q$ has already contacted a quorum of $f + 1$ Fast Paxos nodes as
  part of Fast Paxos. When $Q$ contacts Fast Paxos acceptor $p_j$, it can
  simultaneously send $(I_a, a)$ to the colocated ordering service node $o_j$.
}
and receives responses $(I_a, a, \deps{a}_{j_1}), \ldots, (I_a, a,
\deps{a}_{j_{f+1}})$. If $\deps{a} = \pruned(\cup_j \deps{a}_j)$, then we're
unstuck. $\deps{a}$ is a pruned response from the ordering service, so $Q$ can
propose $(a, \deps{a})$.
%
Otherwise, there is some $(I_a, a, \deps{a}_j)$ where $\deps{a}_j$ includes an
unpruned instance $I_c$ with command $c$ that is not in $\deps{a}$. This is
illustrated in \figref{FastBPaxosNotUnion}. $Q$ proceeds as follows.
\begin{itemize}
  \item
    If $Q$ knows that $(I_c, c, \deps{c})$ has been chosen:
    \begin{itemize}
      \item
        We know that $c \neq \noop$ and that $I_a \notin \deps{c}$ because
        $I_c$ was not pruned.

      \item
        By \invref{PrunedDependencies}, $\deps{c}$ must be a pruned response
        from the ordering service. $I_a$ has not yet been commited, so $I_a$
        cannot have been pruned from $\deps{c}$. Thus, there is a majority of
        ordering service nodes that saw $c$ before $a$.
        %
        \TODO[mwhittaker]{%
          I think this is actually a little subtle. Maybe some other node has
          gotten $I_a$ committed in the meantime with $I_c$ in its
          dependencies. Maybe, but then this Fast Paxos round will fail, so it
          should be okay. We'll need to formalize pruning more.%
        }

      \item
        Thus, it is impossible that $(a, \deps{a})$ was chosen by a superquorum
        in round $k$ because $I_c \notin \deps{a}$, so there must have been a
        superquorum of nodes that saw $a$ before $c$.
        %
        \TODO[mwhittaker]{%
          Elaborate a bit that we can only hit Case 2 when $k = 0$ since it is
          the only fast ballot.%
        }

      \item
        Thus, we are free to propose $(\noop, \emptyset)$.
    \end{itemize}
  \item
    Otherwise:
    \begin{itemize}
      \item
        $Q$ starts recovery for $I_c$ to have $I_c$ chosen. $Q$ makes sure to
        contact the same quorum $\mathcal{Q}$. If after a timeout, the same
        quorum cannot be reached, then it's possible some node in the quorum
        has failed. If so, $Q$ will start recovery over for every instance with
        some new quorum. One quorum is guaranteed to exist since at most $f$
        nodes can fail.
        %
        \TODO[mwhittaker]{%
          This is theoretically nice, but implementation-wise a nightmare. I
          think we can get around this and allow disjoint quorums, but then the
          algorithm will have to do something smarter to avoid deadlock.
          %
          We may be able to have an ordering service node return not only the
          deps of a command, but all of its deps, and so on transitively. If we
          don't want to enforce the same quorum, there probably has to be some
          logic along the lines of figuring out when some $M$ must lie in the
          superquorum of some other command which means there has to be an
          abort somewhere.%
        }

      \item
        After $I_c$ has been chosen, $Q$ re-prunes $\deps{a}$ and repeats this
        loop.

      \item
        Eventually, every $I_c$ will either be (1) chosen as a $\noop$ in which
        case it is pruned, (2) chosen with an edge to $I_a$ in which case it is
        pruned, or (3) chosen without an edge to $I_a$ in which case we propose
        $(\noop, \emptyset)$.
    \end{itemize}
\end{itemize}

This is the entirety of the Deadlock BPaxos algorithm, but there is one small
detail remaning. A node $Q$ recovering $I_a$ may block until it recovers $I_c$.
Can $I_c$ block recovering $I_a$? Or more generally, can a node deadlock itself
during recovery? The answer is no. Let's prove it.

Assume for contradiction there existed a sequence
$
  (I_{a_1}, a_1, \deps{a_1}),
  \ldots
  (I_{a_r}, a_r, \deps{a_r})
$
of gadgets such that the recovery of $a_i$ is blocked on the recovery of
$a_{i+1}$ (with wraparound). We know $a_{i+1} \notin \deps{a_i}$ for every $i$.
%
Some majority of $\mathcal{Q}$, say $M_1$, of nodes unanimously voted for
$\deps{a_1}$ in some round $k$. Every node in $M_1$ saw $a_1$ before $a_2$.
Otherwise, $I_{a_2}$ would be in $\deps{a_1}$.
%
Similarly, some majority $\mathcal{Q}$, say $M_2$, of nodes unanimously voted
for $\deps{a_2}$ in some round $k$. Every node in $M_2$ saw $a_2$ before $a_3$.
Otherwise, $I_{a_3}$ would be in $\deps{a_2}$.
%
Consider some node $o_i \in M_1 \cap M_2$ (which is guaranteed to be
non-empty). Then, $o_i$ saw $a_1$ before $a_2$ before $a_3$. Moreover, every
node in $M_2$ computed the same dependencies, so in fact, every node in $M_2$
saw $a_1$ before $a_2$ before $a_3$. Repeating this argument for every $i$,
we'll eventually find that every node has seen $a_1$ before $a_1$. This is a
contradiction.

\paragraph{Correctness}
\TODO[mwhittaker]{Prove correctness more formally.}

