\section{Simple \BPaxos{}}\seclabel{SimpleBPaxos}
In this section, we introduce \defword{Simple \BPaxos{}}, an inefficient
\BPaxos{} protocol that is designed to be as easy to understand as possible.

\subsection{Overview}
\input{figures/simple_bpaxos_diagram.tex}

As illustrated in \figref{SimpleBPaxos}, a Simple \BPaxos{} deployment consists
of a number of clients, a set of at least $f+1$ Paxos proposers, a set of
$2f+1$ \defword{dependency service nodes}, a set of $2f+1$ Paxos acceptors, and
a set of at least $f+1$ replicas. These nodes have the following responsibilities.
\begin{itemize}
  \item
    The dependency service nodes, collectively called the \defword{dependency
    service}, compute dependencies and maintain the dependency invariant
    (Invariant 2).
  \item
    The proposers and acceptors implement one isntance of Paxos for every
    vertex and maintain the consensus invariant (Invariant 1).
  \item
    The replicas construct and execute conflict graphs and send the results of
    executing commands back to the clients.
\end{itemize}

More concretely, Simple \BPaxos{} executes as follows. The numbers here
correspond to the numbered arrows in \figref{SimpleBPaxos}.
\begin{itemize}
  \item \textbf{(1)}
    When a client wants to propose a state machine command $x$, it sends $x$ to
    \emph{any} of the proposers. Note that with MultiPaxos, only one proposer
    is elected leader, but in Simple \BPaxos{}, every proposer is a leader.

  \item \textbf{(2) and (3)}
    When a proposer $p_i$ receives a command $x$, from a client, it places $x$
    in a vertex with globally unique vertex id $v_x = (p_i, j)$ where $j$ is a
    monotonically increasing integer local to $p_i$. For example, proposer
    $p_i$ places the first command that it receives in vertex $(p_i, 0)$, the
    next command in vertex $(p_i, 1)$, the next in $(p_i, 2)$, and so on. The
    leader then performs a round trip of communication with the dependency
    service. It sends $v_x$ and $x$ to the dependency service, and the
    dependency service replies with the dependencies $\deps{v_x}$. For now, we
    leave this process abstract. We'll explain how the dependency service
    computes dependencies momentarily.

  \item \textbf{(4) and (5)}
    The proposer $p_i$ then executes Phase 2 of Paxos with the acceptors,
    proposing that the value $(x, \deps{v_x})$ be chosen in the instance of
    Paxos associated with vertex $v_x = (p_i, j)$. This is analogous to a
    MultiPaxos leader running Phase 2, proposing the command $x$ be chosen in
    the instance of Paxos associated with log entry $k$.

    Recall from \secref{Background} that the Paxos proposer executing round 0
    can safely bypass Phase 1. By design, we predetermine that the proposer
    $p_i$ executes round $0$ for vertices of the form $(p_i, j)$. This is why
    $p_i$ can safely bypass Phase 1 and immediately execute Phase 2.

    In the normal case, $p_i$ gets the value $(x, \deps{v_x})$ chosen in vertex
    $v_x$. It is also possible that some other proposer erroneously concluded
    that $p_i$ had failed and proposed some other value in vertex $v_x$, but we
    discuss this scenario later.

  \item \textbf{(6)}
    The proposer $p_i$ broadcasts $v_x$, $x$, and $\deps{x}$ to all of the
    replicas. The replicas add vertex $v_x$ to their conflict graph with
    command $x$ and with edges to the vertices in $\deps{x}$. The replicas
    execute their conflict graphs as described in \secref{BipartisanPaxos}.

  \item \textbf{(7)}
    Once a replica executes command $x$, it sends the result of executing
    command $x$ back to the client.
\end{itemize}

\subsection{Dependency Service}
The dependency service consists of $2f+1$ dependency service nodes $d_1, \ldots
d_{wf+1}$. Every dependency service node maintains an acyclic conflict graph.
These conflict graphs are similar but not equal to the conflict graph that
Simple \BPaxos{} ultimately executes.

\newcommand{\out}[1]{\text{out}(#1)}
When a proposer sends a vertex $v_x$ with command $x$ to the dependency
service, it sends $v_x$ and $x$ to every dependency service node. When a
dependency service node $d_i$ receives $v_x$ and $x$, it performs one of the
following two actions depending on whether $d_i$'s graph already contains
vertex $v_x$.
\begin{itemize}
  \item
    If $d_i$'s conflict graph does not contain vertex $v_x$, then $d_i$ adds
    vertex $v_x$ to its graph with command $x$. $d_i$ adds an edge from $v_x$
    to every other vertex $v_y$ with command $y$ if $x$ and $y$ conflict.
    Letting $\out{v_x}$ be the set of vertices to which $v_x$ has an edge,
    $d_i$ then returns $\out{v_x}$ to the proposer.

  \item
    Otherwise, if $d_i$'s conflict graph already contains vertex $v_x$, then
    $d_i$ does not modify its conflict graph. It immediately returns
    $\out{v_x}$ to the proposer.
\end{itemize}
An example execution of a dependency service node is given in
\figref{DependencyService}.

When a proposer receives replies from $f+1$ dependency service nodes, it
takes the union of these responses as the value of $\deps{v_x}$. For example,
imagine $f= 1$ and a proposer receives dependencies $\set{v_w, v_y}$ from $d_1$
and dependencies $\set{v_w, v_z}$ from $d_2$. The proposer computes $\deps{v_x}
= \set{v_w, v_y, v_z}$. The dependency service maintains
\invref{DependencyService}.

{\input{figures/dependency_service.tex}}

\begin{invariant}\invlabel{DependencyService}
If two conflicting commands $x$ and $y$ in vertices $v_x$ and $v_y$ yield
dependencies $\deps{v_x}$ and $\deps{v_y}$ from the dependency service, then
either $v_x \in \deps{v_y}$ or $v_y \in \deps{v_x}$ or both.
\end{invariant}

\begin{proof}
  Consider conflicting commands $x$ and $y$ in vertices $v_x$ and $v_y$ with
  dependencies $\deps{v_x}$ and $\deps{v_y}$ computed by the dependency
  service. $\deps{v_x}$ is the union of dependencies computed by $f+1$
  dependency service nodes $Q_x$. Similarly, $\deps{v_y}$ is the union of
  dependencies computed by $f+1$ dependency service nodes $Q_y$. Because $f+1$
  is a majority of $2f+1$, $Q_x$ and $Q_y$ necessarily intersect. That is,
  there is some dependency service node $d_i$ that is $Q_x$ and $Q_y$.  $d_i$
  either received $v_x$ or $v_y$ first.  If it received $v_x$ first, then it
  returns $v_x$ as a dependency of $v_y$, so $v_x \in \deps{v_y}$.  If it
  received $v_y$ first, then it returns $v_y$ as a dependency of $v_x$, so $v_y
  \in \deps{v_x}$.
\end{proof}

Note that the dependency service may process a vertex more than once, yielding
different dependencies each time. For example, a proposer may sent $v_x$ and
$x$ to the dependency service and get back dependencies $\set{v_w, v_y}$.  The
proposer might resend $v_x$ and $x$ to the dependency service and get a
different set of dependencies $\set{v_y, v_z}$. Even though the dependency
service may compute different dependencies for the same vertex, the dependency
service still maintains \invref{DependencyService} for every possible pair of
computed dependencies.


\subsection{An Example}
\input{figures/simple_bpaxos_example.tex}

An example execution of Simple \BPaxos{} with $f=1$ is illustrated in
\figref{SimpleBPaxosExample}. In \figref{SimpleBPaxosExample1}, Simple \BPaxos{}
node $b_1$ receives command $x$ from a client, while $b_2$ receives conflicting
command $y$. $b_1$ sends tuple $(I_x, x)$ to the dependency service nodes,
while $b_2$ sends $(I_y, y)$. $d_1$ receives $x$ and then $y$, $d_2$ receives
$y$ and then $x$, and $d_3$ does not receive anything because of a network
partition. $d_1$ replies with values $(I_x, x, \emptyset)$ and $(I_y, y,
\set{I_x})$, while $d_2$ replies with values $(I_y, y, \emptyset)$ and $(I_x,
x, \set{I_y})$.  $b_1$ and $b_2$ compute responses $(I, x, \emptyset{} \cup
\set{I_y})$ and $(I, y, \set{I_x} \cup \emptyset{})$ from the dependency
service respectively, and propose values $(x, \set{I_y})$ in instance $I_x$ and
$(y, \set{I_x})$ in instance $I_y$ to the consensus service (not illustrated in
\figref{SimpleBPaxosExample}). The consensus service chooses these proposed
values, and after communicating with one another, both $b_1$ and $b_2$ learn
the partial \BPaxos{} graph shown in \figref{SimpleBPaxosExample3}. Then, they
both execute $x$ and $y$ in some arbitrary but deterministic order (e.g., in
increasing hash order).

\subsection{Recovery}
Note that it is possible that a command $x$ chosen in instance $I$ depends on
an unchosen instance $I'$. If instance $I'$ remains forever unchosen, then the
command $x$ will never be executed. To avoid this liveness violation, if any
Simple \BPaxos{} node $b_i$ notices that instance $I'$ has been unchosen for some
time, $b_i$ can propose to the consensus service that the command $\noop$ be
chosen in instance $I'$ with no dependencies. $\noop$ is a distinguished
command that does not affect the state machine and does not conflict with any
other command.
%
Alternatively, $b_i$ can contact the dependency service and check if any
dependency service node has recorded a command $y$ in instance $I'$. If such a
command exists, $b_i$ can send the tuple $(I', y)$ to the dependency service,
and propose $y$ with the resulting dependencies to the consensus service. If no
such $y$ exists, $b_i$ can propose a $\noop$.

\subsection{Safety}
We now prove that Simple \BPaxos{} maintains \invref{ConsensusInvariant} and
\invref{ConflictInvariant}.
%
Simple \BPaxos{} maintains \invref{ConsensusInvariant} trivially by leveraging the
consensus service. Simple \BPaxos{} maintains \invref{ConflictInvariant} by
maintaining the following invariant.

\begin{invariant}\invlabel{SimpleBpaxosInvariant}
  For every instance $I$, a value $(x, \deps{I})$ is chosen in instance $I$
  only if $(I, x, \deps{I})$ is a response from the dependency service or if
  $(x, \deps{I}) = (\noop, \emptyset)$.
\end{invariant}

\invref{ConflictInvariant} follows immediately from \invref{DependencyService}
and \invref{SimpleBpaxosInvariant}. Simple \BPaxos{} maintains
\invref{SimpleBpaxosInvariant} because Simple \BPaxos{} nodes only propose
dependencies computed by the dependency service (or $\noop$s). Note that
proposing $\noop$s does not affect \invref{ConflictInvariant} because
$\noop$s do not conflict with any other command, so \invref{ConflictInvariant}
holds vacuously in that case.
